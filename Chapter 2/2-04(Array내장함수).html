<html>
<head>
    <title>Array 내장함수</title>
</head>
<body>
    <div id = "div1"></div>
    <script>
        var fruits1 = ["Banana", "Orange", "Apple"];
        // toString()
        console.log(fruits1);              
        console.log(fruits1.toString());   // 배열 안에 있는 문자열들만 출력 (Banana, Orange, Apple)
        
        // join() 
        console.log(fruits1.join(" - "));  // 배열 속 문자들 사이에 " - "를 추가해줌 (Banana - Orange - Apple)

        var txt1 = "Banana<br>";
        txt1 += "Orange<br>";
        txt1 += "Apple";
        console.log(txt1);
        // document.write(txt1);
        document.getElementById("div1").innerHTML = txt1;

        var arr1 = [];
        arr1.push("Banana");
        arr1.push("Orange");
        arr1.push("Apple");
        // console.log(arr1);
        document.getElementById("div1").innerHTML = arr1.join("<br>");

        // pop() : 배열의 가장 마지막 항목을 제거하여 리턴
        var fruits2 = ["Banana", "Orange","Apple"];
        var arr2 = fruits2.pop();
        console.log(arr2);           // "Apple"
        console.log(fruits2);        // ['Banana', 'Orange'] 
        fruits2.push("kiwi");
        console.log(fruits2);

        // shift() : 배열의 첫번째 항목을 제거하여 리턴 
        var fruits3 = ["Banana", "Orange","Apple"];
        var str = fruits3.shift();
        console.log(str);           // "str = "banana"
        console.log(fruits3);        // ['Banana', 'Orange'] 

        // unshift() :배열의 첫번째에 새로운 항목을 추가함
        var fruits4 = ["Banana", "Orange","Apple"];
        var str = fruits4.unshift("Lemon");       
        console.log(fruits4);        // ['Lemon', 'Banana', 'Orange', 'Apple']

        fruits4[0] = "Grape";       // Lemon -> Grape
        console.log(fruits4);
        console.log(fruits4.length);      // 4
        fruits4[fruits4.length-1] = "Peach";
        console.log(fruits4);


        // splice(a,b) 배열 중간에 삽입
        // a : 시작 위치
        // b :  삭제할 항목 수
        var fruits5 = ["Banana", "Orange" ,"Apple"];
        // fruits5.splice(1,2);          // "Banana만 나옴"
        // fruits5.splices(1); 와 같음
        fruits5.splice(1,0, "Lemon","Kiwi");       // 1,0 (삭제안함), (시작위치 뒤에 넣고 싶은 것들)
        console.log(fruits5); 

        // concat() : 두개의 배열을 하나로 만듦
        var Merpi1 = ["퍼피"];
        var Merpi2 = ["캣시"];
        
        var Merpi = Merpi1.concat(Merpi2);
        console.log(Merpi);


        // slice(a,b) : a부터 b-1까지 항목을 가져옴
        var fruits6 = ["Banana", "Orange" ,"Apple", "Kiwi"];
        // var fruits6 = fruits6.slice(1);   // index가 하나라면 시작인덱스부터 끝까지 들고옴
        var fruits6 = fruits6.slice(1,3);   

        console.log(fruits6);

        // sort() : 정렬
        var fruits7 = ["Banana", "Orange" ,"Apple", "Kiwi", "Lemon", "Peach"];
        console.log(fruits7.sort());

        // 숫자를 문자로 변환해서 비교함 (1,2,3,4... 로 정렬)
        var points = [40,100,70,21,99];
        console.log(points.sort());    // [100, 21, 40, 70, 99]

        // points.sort(function(a,b) {
        //     if (a > b)  return 1;
        //     else if (a < b) return -1;
        //     else return 0;
        // });

        points.sort(function(a, b) {
            return a - b;    // a가 더 크면 양수, b가 더 크면 음수로 나와서 구분 가능
        });

        console.log(points);
        console.log(points.reverse());

        // Object
        var peep = [
            {name: "퍼피", point:78},
            {name: "캣시", point:92},
            {name: "왈라비", point:44},
            {name: "랏시", point:12},
        ];

        // console.log(peep.sort());   정렬 안됨
        // peep.sort(function (a,b){  
        //     if (a.point > b.point) return 1;
        //     else if (a.point < b.point) return -1;
        //     else return 0;
        // });

        // peep.sort(function(a,b) {
        //     return a.point - b.point;
        // });

        peep.sort(function(a,b) {
            return (a.point > b.point) ? 1 : (a.point < b.point ? -1 : 0);
        })
        console.log(peep);

        
        // filter()
        var peep = [
            {name: "퍼피", point:78, type:"멍멍"},
            {name: "캣시", point:92, type:"야옹"},
            {name: "왈라비", point:44, type:"왈랍"},
            {name: "랏시", point:12, type:"랏랏"},
        ];

        // 1. for문
        var wallap = [];
        for (var i = 0; i < peep.length; i++ ) {
            if (peep[i].type == "왈랍") wallap.push(peep[i]);
        }
        console.log(wallap);

        // 2. filter
        var wallap2 = peep.filter(function(pi) {
            return pi.type == "왈랍";
        });
        console.log(wallap2);

        // reduce()

        // int total = 0;
        // for (int i=1; i <= 100; i ++ ) {
        //     total+=i;
        // }
        // System.out.println(total);
            
        // 1. for문
        var arr3 = [1,2,3,4,5];
        var total = 0;
        for (var x of arr3) {
            // console.log(x);
            total += x;
        }
        console.log(total);

        // 2. reduce(a, c)   
        // a : accumulator - 누산기 (위의 x)
        // c : curentiValue - 현재값 (위의 total)

        var arr4 = [1,2,3,4,5];
        var total = arr4.reduce(function(a,c){   // 자동으로 바뀜
            return a + c;
        });
        console.log(total);


        // map() : filter()와는 다른 형태로 새로운 배열을 생성
        var userList = [
            {firstName:"메르피즈", lastName:"두근두근", email:"doki@gmail.com"},
            {firstName:"메르피즈", lastName:"들썩들썩", email:"dance@gmail.com"},
            {firstName:"메르피즈", lastName:"숲의", email:"forest@gmail.com"},
            {firstName:"마미", lastName:"메르피", email:"mommy@gmail.com"},
        ];

        // 기존의 배열로부터 연산을 해서 기존에 없는 새로운 배열을 만들어서 리턴 
        userList2 = userList.map(function(user) {
            return {fullName : user.lastName + user.firstName, mmail:user.email}
        });

        console.log(userList2);

    </script>
</body>
</html>